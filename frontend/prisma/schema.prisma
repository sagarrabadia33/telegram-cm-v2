generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Contact {
  id               String            @id @default(cuid())
  firstName        String?
  lastName         String?
  displayName      String?
  primaryEmail     String?           @unique
  primaryPhone     String?           @unique
  avatarUrl        String?
  bio              String?
  dealValue        Int?
  dealStage        String?
  isVip            Boolean           @default(false)
  lastContactedAt  DateTime?
  isOnline         Boolean           @default(false)
  onlineStatus     String?
  lastSeenAt       DateTime?
  lastStatusCheck  DateTime?
  notes            String?
  metadata         Json?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  campaignMessages CampaignMessage[]
  tags             ContactTag[]
  conversations    Conversation[]
  followUps        FollowUp[]
  messages         Message[]
  sourceIdentities SourceIdentity[]

  @@index([primaryEmail])
  @@index([primaryPhone])
  @@index([dealStage])
  @@index([isVip])
  @@index([lastContactedAt])
  @@index([isOnline])
  @@index([createdAt])
}

model Tag {
  id            String            @id @default(cuid())
  name          String            @unique
  color         String?
  description   String?
  category      String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  contacts      ContactTag[]
  conversations ConversationTag[]
  suggestions   TagSuggestion[]
  toneProfile   ToneProfile?      // Tag-specific tone profile for draft replies

  // AI CONVERSATION INTELLIGENCE (per-tag configuration)
  aiEnabled           Boolean   @default(false)      // Enable AI analysis for this tag
  aiSystemPrompt      String?   @db.Text             // Custom system prompt for AI analysis
  aiTeamMembers       String[]                       // Team member names/usernames (e.g., ["Jesus", "Prathamesh"])
  aiOwnerNames        String[]                       // Owner names that trigger escalation (e.g., ["Shalin"])
  aiAnalysisInterval  Int       @default(5)          // Minutes between AI analysis runs
  aiLastAnalyzedAt    DateTime?                      // When AI last ran for this tag's conversations

  // MODULAR TAG-SPECIFIC AI CONFIGURATION
  aiStatusOptions     Json?                          // Array of valid statuses for this tag (e.g., ["nurturing", "active", "dormant"])
  aiStatusLabels      Json?                          // Display labels for statuses (e.g., {"nurturing": "Nurturing", "active": "Active"})
  aiStatusColors      Json?                          // Badge colors for statuses (e.g., {"nurturing": "blue", "active": "green"})
  aiColumnConfig      Json?                          // Column configuration for list view (e.g., ["type", "status", "action", "summary"])
  aiSignalDefinitions Json?                          // Custom signals to detect (e.g., {"positive": [...], "warning": [...], "opportunity": [...]})

  @@index([category])
  @@index([aiEnabled])
}

model ContactTag {
  id        String   @id @default(cuid())
  contactId String
  tagId     String
  addedAt   DateTime @default(now())
  contact   Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([contactId, tagId])
  @@index([contactId])
  @@index([tagId])
}

model ConversationTag {
  id             String       @id @default(cuid())
  conversationId String
  tagId          String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tag            Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([conversationId, tagId])
  @@index([conversationId])
  @@index([tagId])
}

model SourceIdentity {
  id               String    @id @default(cuid())
  contactId        String
  source           String
  externalId       String
  externalUsername String?
  isPrimary        Boolean   @default(false)
  isActive         Boolean   @default(true)
  externalData     Json?
  lastSyncedAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  contact          Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([source, externalId])
  @@index([contactId])
  @@index([source, externalId])
  @@index([source, externalUsername])
}

model Conversation {
  id                  String            @id @default(cuid())
  contactId           String?
  source              String
  externalChatId      String
  type                String
  title               String?
  avatarUrl           String?
  summary             String?
  summaryGeneratedAt  DateTime?
  lastTopic           String?
  lastMessageAt       DateTime?
  needsReply          Boolean           @default(false)
  priorityScore       Int               @default(0)
  sentiment           String?
  intentLevel         String?
  keyPoints           Json?
  hasQuestion         Boolean           @default(false)
  lastSyncedMessageId String?
  lastSyncedAt        DateTime?
  syncStatus          String?
  syncError           String?
  isSyncDisabled      Boolean           @default(false)

  // Unread tracking (Telegram-style per-conversation)
  unreadCount         Int               @default(0)
  lastReadMessageId   String?           // External msg ID of last read message
  lastReadAt          DateTime?         // When user last read this conversation

  metadata            Json?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Group triage preference (user-configurable)
  triagePreference    String?           // 'auto_clear' | 'auto_review' | 'smart' (default)

  // AI CONVERSATION INTELLIGENCE (tag-based analysis results)
  aiStatus              String?           // AI-determined status (tag-specific options)
  aiStatusReason        String?           // Brief explanation of why this status
  aiStatusUpdatedAt     DateTime?         // When AI last updated the status

  // MANUAL STATUS OVERRIDE (user can override AI status)
  manualStatus          String?           // User-set status (takes precedence over aiStatus)
  manualStatusSetAt     DateTime?         // When user set the manual status
  aiStatusRecommendation String?          // AI's suggestion if status should change (shown as recommendation)
  aiStatusRecommendationReason String?    // Why AI recommends this change
  aiSummary             String?   @db.Text // 1-2 sentence summary of recent conversation
  aiSummaryUpdatedAt    DateTime?         // When summary was last generated
  aiChurnRisk           String?           // 'high' | 'medium' | 'low' | null
  aiChurnSignals        Json?             // Array of detected churn signals
  aiSuggestedAction     String?           // Recommended next action (detailed)
  aiAction              String?           // AI's action recommendation: 'Reply Now' | 'Schedule Call' | 'Send Resource' | 'Check In' | 'Escalate' | 'On Track' | 'Monitor'
  aiLastAnalyzedMsgId   String?           // Track which message was last analyzed
  aiAnalyzing           Boolean   @default(false) // True when AI analysis is in progress
  aiAnalyzingStartedAt  DateTime?         // When analysis started (for timeout detection)

  // WORLD-CLASS INTELLIGENCE FIELDS (computed during analysis)
  aiHealthScore         Int?              // Relationship health 0-100
  aiHealthFactors       Json?             // { responsiveness, sentiment, engagement, resolution } each 0-25
  aiLifecycleStage      String?           // 'onboarding' | 'active' | 'at_risk' | 'dormant' | 'churning'
  aiUrgencyLevel        String?           // 'critical' | 'high' | 'medium' | 'low'
  aiSentiment           String?           // 'positive' | 'negative' | 'neutral' | 'mixed'
  aiSentimentTrajectory String?           // 'improving' | 'stable' | 'deteriorating' | 'unknown'
  aiFrustrationSignals  Json?             // Array of detected frustration phrases
  aiCriticalInsights    Json?             // Array of top critical insights

  contact             Contact?          @relation(fields: [contactId], references: [id])
  tags                ConversationTag[]
  followUps           FollowUp[]
  members             GroupMember[]
  messages            Message[]
  notes               ConversationNote[]
  outgoingMessages    OutgoingMessage[]
  outgoingReactions   OutgoingReaction[]
  telegramChat        TelegramChat?

  // Inbox Zero relations
  triage              MessageTriage?
  commitments         Commitment[]
  tagSuggestions      TagSuggestion[]

  @@unique([source, externalChatId])
  @@index([contactId])
  @@index([source])
  @@index([lastMessageAt(sort: Desc)])
  @@index([needsReply])
  @@index([priorityScore])
  @@index([hasQuestion])
  @@index([syncStatus])
  @@index([isSyncDisabled])
  @@index([unreadCount])
}

model Message {
  id                String                   @id @default(cuid())
  conversationId    String
  contactId         String?
  source            String
  externalMessageId String
  direction         String
  contentType       String
  subject           String?
  body              String?
  status            String?
  sentAt            DateTime
  deliveredAt       DateTime?
  readAt            DateTime?
  containsQuestion  Boolean                  @default(false)
  sentiment         String?
  keywords          String[]
  hasAttachments    Boolean                  @default(false)
  attachments       Json?
  metadata          Json?
  reactions         Json?                    // [{emoji: "üëç", count: 2, userReacted: true}, ...]
  createdAt         DateTime                 @default(now())
  search_vector     Unsupported("tsvector")?
  campaignMessage   CampaignMessage?
  contact           Contact?                 @relation(fields: [contactId], references: [id])
  conversation      Conversation             @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([source, conversationId, externalMessageId])
  @@index([conversationId])
  @@index([contactId])
  @@index([sentAt(sort: Desc)])
  @@index([source])
  @@index([containsQuestion])
  @@index([direction])
  @@index([search_vector], map: "msg_search_vector_idx", type: Gin)
}

model GroupMember {
  id             String       @id @default(cuid())
  conversationId String
  externalUserId String
  username       String?
  firstName      String?
  lastName       String?
  role           String?
  joinedAt       DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([conversationId, externalUserId])
  @@index([conversationId])
  @@index([externalUserId])
}

model FollowUp {
  id             String        @id @default(cuid())
  conversationId String?
  contactId      String?
  title          String
  notes          String?
  priority       String        @default("medium")
  status         String        @default("pending")
  dueDate        DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  contact        Contact?      @relation(fields: [contactId], references: [id])
  conversation   Conversation? @relation(fields: [conversationId], references: [id])

  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([contactId])
}

model Campaign {
  id               String            @id @default(cuid())
  name             String
  description      String?
  targetingType    String
  targetingRules   Json?
  channels         String[]
  messageTemplates Json
  scheduleType     String
  scheduledFor     DateTime?
  timezone         String?
  status           String            @default("draft")
  recipientCount   Int               @default(0)
  sentCount        Int               @default(0)
  deliveredCount   Int               @default(0)
  readCount        Int               @default(0)
  repliedCount     Int               @default(0)
  failedCount      Int               @default(0)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  messages         CampaignMessage[]

  @@index([status])
  @@index([scheduledFor])
}

model CampaignMessage {
  id            String    @id @default(cuid())
  campaignId    String
  contactId     String
  messageId     String?   @unique
  channel       String
  status        String    @default("pending")
  sentAt        DateTime?
  deliveredAt   DateTime?
  readAt        DateTime?
  repliedAt     DateTime?
  failureReason String?
  retryCount    Int       @default(0)
  createdAt     DateTime  @default(now())
  campaign      Campaign  @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  contact       Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  message       Message?  @relation(fields: [messageId], references: [id])

  @@index([campaignId])
  @@index([contactId])
  @@index([status])
  @@index([channel])
}

model Workflow {
  id           String        @id @default(cuid())
  name         String
  description  String?
  triggerType  String
  triggerRules Json
  actions      Json
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  runs         WorkflowRun[]

  @@index([isActive])
  @@index([triggerType])
}

model WorkflowRun {
  id           String    @id @default(cuid())
  workflowId   String
  contactId    String?
  status       String
  triggeredBy  String?
  startedAt    DateTime?
  completedAt  DateTime?
  executionLog Json?
  createdAt    DateTime  @default(now())
  workflow     Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([workflowId])
  @@index([status])
  @@index([createdAt])
}

model Broadcast {
  id             String    @id @default(cuid())
  title          String
  message        String
  tagIds         Json
  status         String    @default("draft")
  scheduledFor   DateTime?
  sentAt         DateTime?
  recipientCount Int?
  sentCount      Int?
  failedCount    Int?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([scheduledFor])
}

model SyncJob {
  id             String    @id @default(cuid())
  jobType        String
  source         String
  status         String    @default("pending")
  conversationId String?
  cursor         String?
  startedAt      DateTime?
  completedAt    DateTime?
  itemsProcessed Int       @default(0)
  itemsFailed    Int       @default(0)
  errors         Json?
  retryCount     Int       @default(0)
  nextRetryAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([source])
  @@index([jobType])
  @@index([conversationId])
  @@index([createdAt])
}

model SyncHealth {
  id                  String   @id @default(cuid())
  syncType            String
  source              String
  status              String
  totalItems          Int      @default(0)
  successCount        Int      @default(0)
  failureCount        Int      @default(0)
  duration            Int?
  circuitBreakerState String?
  errors              Json?
  createdAt           DateTime @default(now())

  @@index([syncType, source])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

model TelegramChat {
  id             String       @id @default(cuid())
  conversationId String       @unique
  telegramChatId String       @unique
  type           String
  title          String?
  username       String?
  memberCount    Int?
  isActive       Boolean      @default(true)
  metadata       Json?
  lastSyncedAt   DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([telegramChatId])
  @@index([type])
}

model TelegramSession {
  id            String   @id @default(cuid())
  sessionType   String   @unique
  sessionString String
  phoneNumber   String
  isActive      Boolean  @default(true)
  lastUsedAt    DateTime @updatedAt
  createdAt     DateTime @default(now())
  session_name  String   @unique(map: "unique_session_name") @default("default") @db.VarChar(255)

  @@index([isActive])
  @@index([phoneNumber])
}

model SyncLock {
  id          String   @id @default(cuid())
  lockType    String
  lockKey     String
  processId   String
  hostname    String?
  acquiredAt  DateTime @default(now())
  expiresAt   DateTime
  heartbeatAt DateTime @default(now())
  metadata    Json?

  @@unique([lockType, lockKey])
  @@index([expiresAt])
  @@index([processId])
}

model ListenerState {
  id               String    @id @default("singleton")
  status           String
  lastHeartbeat    DateTime  @default(now())
  lastMessageAt    DateTime?
  processId        String?
  hostname         String?
  startedAt        DateTime?
  messagesReceived Int       @default(0)
  connectionInfo   Json?
  errors           Json?
  updatedAt        DateTime  @updatedAt
}

model TelegramWorkerSession {
  id           Int       @id @default(autoincrement())
  session_name String    @unique @default("default") @db.VarChar(255)
  session_data Bytes
  created_at   DateTime? @default(now()) @db.Timestamptz(6)
  updated_at   DateTime? @default(now()) @db.Timestamptz(6)
}

// LINEAR-STYLE OUTBOX: Reliable message sending queue
// Messages are stored here first, then processed by the Telegram worker
// This ensures 100% delivery even if the worker crashes
model OutgoingMessage {
  id                String    @id @default(cuid())
  conversationId    String

  // Message content
  text              String?                   // Text body (optional if sending media only)
  replyToMessageId  String?                   // External message ID to reply to

  // Attachments (Telegram-style: photo, document, video, audio, voice)
  attachmentType    String?                   // 'photo' | 'document' | 'video' | 'audio' | 'voice' | null
  attachmentUrl     String?                   // URL or file path to the attachment
  attachmentName    String?                   // Original filename for documents
  attachmentMimeType String?                  // MIME type for proper handling
  attachmentCaption String?                   // Caption for media (Telegram supports this)

  // Delivery status (Linear-style state machine)
  status            String    @default("pending")  // 'pending' | 'sending' | 'sent' | 'failed'
  sentMessageId     String?                        // Telegram message ID after sending
  errorMessage      String?                        // Error details if failed
  retryCount        Int       @default(0)          // Number of retry attempts
  maxRetries        Int       @default(3)          // Maximum retries before permanent failure

  // Processing metadata
  lockedBy          String?                   // Worker process ID that claimed this message
  lockedAt          DateTime?                 // When the lock was acquired
  scheduledFor      DateTime?                 // For scheduled messages (future feature)

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  sentAt            DateTime?                 // When actually sent to Telegram

  // Relations
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([conversationId])
  @@index([createdAt])
  @@index([scheduledFor])
  @@index([lockedBy, lockedAt])
}

// LINEAR-STYLE OUTBOX: Reliable reaction sending queue
// Reactions are stored here first, then processed by the Telegram worker
// This ensures 100% delivery even if the worker crashes
model OutgoingReaction {
  id             String    @id @default(cuid())
  conversationId String
  messageId      String    // External Telegram message ID to react to
  emoji          String    // Reaction emoji (e.g., "üëç", "‚ù§Ô∏è", "üî•")
  action         String    @default("add")  // "add" or "remove"

  // Delivery status (Linear-style state machine)
  status         String    @default("pending")  // 'pending' | 'sending' | 'sent' | 'failed'
  retryCount     Int       @default(0)
  maxRetries     Int       @default(3)
  errorMessage   String?

  // Processing metadata
  lockedBy       String?
  lockedAt       DateTime?

  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  sentAt         DateTime?

  // Relations
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([conversationId])
  @@index([createdAt])
  @@index([lockedBy, lockedAt])
}

// File uploads storage for attachments
model FileUpload {
  id            String    @id @default(cuid())
  filename      String                    // Original filename
  mimeType      String                    // MIME type
  size          Int                       // File size in bytes
  storageKey    String    @unique         // Key in storage (local path or cloud URL)
  storageType   String    @default("local") // 'local' | 's3' | 'cloudflare'
  uploadedBy    String?                   // User/session identifier
  expiresAt     DateTime?                 // For temporary files
  metadata      Json?                     // Additional file metadata
  createdAt     DateTime  @default(now())

  @@index([storageKey])
  @@index([createdAt])
  @@index([expiresAt])
}

// Timeline-based notes for conversations (Linear-style)
// Allows users to add multiple notes over time with different types
model ConversationNote {
  id             String    @id @default(cuid())
  conversationId String

  // Note content
  type           String    @default("note")  // 'note' | 'meeting' | 'file' | 'call'
  title          String?                     // Optional title for meetings/calls
  content        String                      // Main text content

  // File attachments (optional)
  fileName       String?
  fileUrl        String?
  fileMimeType   String?
  fileSize       Int?

  // Metadata for flexible data (meeting duration, call type, etc.)
  metadata       Json?

  // Timestamps
  eventAt        DateTime?                   // When the event happened (for meetings/calls)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt(sort: Desc)])
  @@index([type])
}

// =============================================================================
// ANALYTICS TABLES
// =============================================================================

// Immutable event log for all user interactions
model AnalyticsEvent {
  id            String   @id @default(cuid())

  // Event identification
  eventType     String   // e.g., "conversation_opened", "message_sent", "filter_applied"
  eventCategory String   // "navigation", "messaging", "contacts", "search", "ai", "tags"

  // Context
  sessionId     String?  // Optional: group events by page load
  userId        String?  // For future multi-user support

  // Related entities (nullable - depends on event)
  conversationId String?
  contactId      String?
  tagId          String?

  // Event details
  properties    Json?    // Flexible properties per event type

  // Client info
  deviceType    String?  // "desktop", "mobile", "tablet"
  viewMode      String?  // "messages", "contacts"

  // Timing
  timestamp     DateTime @default(now())
  durationMs    Int?     // For timed events (search, AI response)

  @@index([eventType])
  @@index([eventCategory])
  @@index([sessionId])
  @@index([timestamp])
  @@index([conversationId])
  @@index([contactId])
}

// Pre-aggregated daily metrics for fast dashboard queries
model DailyMetrics {
  id            String   @id @default(cuid())
  date          DateTime @db.Date
  userId        String?  // For future multi-user

  // Engagement metrics
  sessionsCount     Int @default(0)
  totalDurationMs   Int @default(0)
  avgSessionDurationMs Int @default(0)

  // Feature usage counts
  conversationsOpened   Int @default(0)
  messagesSent          Int @default(0)
  messagesReceived      Int @default(0)
  contactsViewed        Int @default(0)
  searchesPerformed     Int @default(0)
  aiPromptsSubmitted    Int @default(0)
  tagsAssigned          Int @default(0)
  notesCreated          Int @default(0)
  filtersApplied        Int @default(0)
  contactsExported      Int @default(0)

  // Quick filter usage
  filterActive7d    Int @default(0)
  filterActive30d   Int @default(0)
  filterUntagged    Int @default(0)
  filterHighVolume  Int @default(0)
  filterNeedFollowUp Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, userId])
  @@index([date])
  @@index([userId])
}

// =============================================================================
// INBOX ZERO TABLES
// =============================================================================

// Message Triage - AI classification for inbox zero
model MessageTriage {
  id                String    @id @default(cuid())
  conversationId    String    @unique

  // Classification
  bucket            String    // 'respond' | 'review' | 'clear'
  confidence        Float     @default(0.0)
  reason            String?
  priorityScore     Int       @default(5) // 1-10, higher = more urgent (tag-aware)

  // RESPOND signals
  isDirectMention   Boolean   @default(false)
  isQuestion        Boolean   @default(false)
  hasOverduePromise Boolean   @default(false)
  isComplaint       Boolean   @default(false)

  // Conversation state tracking (for accurate triage)
  conversationState String?   // 'waiting_on_them' | 'waiting_on_you' | 'concluded' | 'ongoing'
  suggestedAction   String?   // 'reply' | 'follow_up' | 'wait' | 'close'

  // AI draft reply (tag-aware)
  draftReply        String?
  draftTone         String?   @default("casual")

  // User action
  status            String    @default("pending") // 'pending' | 'actioned' | 'snoozed' | 'dismissed'
  snoozeUntil       DateTime?
  actionedAt        DateTime?

  // Timestamps
  lastMessageId     String?   // Track which message triggered this
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([bucket])
  @@index([status])
  @@index([priorityScore(sort: Desc)])
  @@index([createdAt])
}

// Commitment tracking - promises extracted from messages
model Commitment {
  id                String    @id @default(cuid())
  conversationId    String

  content           String    // What was promised
  extractedFrom     String?   // Original quote
  dueDate           DateTime?
  direction         String    // 'outbound' (user promised) | 'inbound' (they promised)

  status            String    @default("pending") // 'pending' | 'completed' | 'cancelled'
  completedAt       DateTime?

  confidence        Float?
  isManual          Boolean   @default(false)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([status])
  @@index([dueDate])
  @@index([direction])
}

// Tag suggestions with high confidence
model TagSuggestion {
  id                String    @id @default(cuid())
  conversationId    String
  tagId             String

  reason            String
  confidence        Float
  signalType        String?   // 'buying_signal' | 'relationship' | 'intent'

  status            String    @default("pending") // 'pending' | 'accepted' | 'rejected'

  createdAt         DateTime  @default(now())

  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tag               Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([conversationId, tagId])
  @@index([status])
  @@index([confidence])
}

// =============================================================================
// TONE PROFILE (for AI draft replies matching user's writing style)
// =============================================================================

// Stores analyzed writing patterns for generating tone-matched draft replies
model ToneProfile {
  id                String    @id @default(cuid())
  tagId             String?   @unique // null = global profile, non-null = tag-specific

  // Writing patterns extracted from message history
  greetingPatterns  Json?     // ["Hey!", "Hi there", "Morning!"]
  signOffPatterns   Json?     // ["Cheers", "Best", "Thanks!"]
  emojiFrequency    Float     @default(0.0) // 0.0-1.0: percentage of messages with emojis
  formalityLevel    Float     @default(0.5) // 0.0 = very casual, 1.0 = very formal
  averageLength     Int       @default(50)  // Average message length in characters
  commonPhrases     Json?     // ["let me know", "sounds good", "makes sense"]

  // Analysis metadata
  sampleCount       Int       @default(0)   // Number of messages analyzed
  sampleMessages    Json?     // Sample messages for context in prompts

  // Timestamps
  builtAt           DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  tag               Tag?      @relation(fields: [tagId], references: [id], onDelete: SetNull)

  @@index([tagId])
  @@index([builtAt])
}
