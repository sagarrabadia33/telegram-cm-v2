generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Contact {
  id               String            @id @default(cuid())
  firstName        String?
  lastName         String?
  displayName      String?
  primaryEmail     String?           @unique
  primaryPhone     String?           @unique
  avatarUrl        String?
  bio              String?
  dealValue        Int?
  dealStage        String?
  isVip            Boolean           @default(false)
  lastContactedAt  DateTime?
  isOnline         Boolean           @default(false)
  onlineStatus     String?
  lastSeenAt       DateTime?
  lastStatusCheck  DateTime?
  notes            String?
  metadata         Json?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  campaignMessages CampaignMessage[]
  tags             ContactTag[]
  conversations    Conversation[]
  followUps        FollowUp[]
  messages         Message[]
  sourceIdentities SourceIdentity[]

  @@index([primaryEmail])
  @@index([primaryPhone])
  @@index([dealStage])
  @@index([isVip])
  @@index([lastContactedAt])
  @@index([isOnline])
  @@index([createdAt])
}

model Tag {
  id            String            @id @default(cuid())
  name          String            @unique
  color         String?
  description   String?
  category      String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  contacts      ContactTag[]
  conversations ConversationTag[]

  @@index([category])
}

model ContactTag {
  id        String   @id @default(cuid())
  contactId String
  tagId     String
  addedAt   DateTime @default(now())
  contact   Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([contactId, tagId])
  @@index([contactId])
  @@index([tagId])
}

model ConversationTag {
  id             String       @id @default(cuid())
  conversationId String
  tagId          String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tag            Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([conversationId, tagId])
  @@index([conversationId])
  @@index([tagId])
}

model SourceIdentity {
  id               String    @id @default(cuid())
  contactId        String
  source           String
  externalId       String
  externalUsername String?
  isPrimary        Boolean   @default(false)
  isActive         Boolean   @default(true)
  externalData     Json?
  lastSyncedAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  contact          Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([source, externalId])
  @@index([contactId])
  @@index([source, externalId])
  @@index([source, externalUsername])
}

model Conversation {
  id                  String            @id @default(cuid())
  contactId           String?
  source              String
  externalChatId      String
  type                String
  title               String?
  avatarUrl           String?
  summary             String?
  summaryGeneratedAt  DateTime?
  lastTopic           String?
  lastMessageAt       DateTime?
  needsReply          Boolean           @default(false)
  priorityScore       Int               @default(0)
  sentiment           String?
  intentLevel         String?
  keyPoints           Json?
  hasQuestion         Boolean           @default(false)
  lastSyncedMessageId String?
  lastSyncedAt        DateTime?
  syncStatus          String?
  syncError           String?
  isSyncDisabled      Boolean           @default(false)

  // Unread tracking (Telegram-style per-conversation)
  unreadCount         Int               @default(0)
  lastReadMessageId   String?           // External msg ID of last read message
  lastReadAt          DateTime?         // When user last read this conversation

  metadata            Json?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  contact             Contact?          @relation(fields: [contactId], references: [id])
  tags                ConversationTag[]
  followUps           FollowUp[]
  members             GroupMember[]
  messages            Message[]
  outgoingMessages    OutgoingMessage[]
  telegramChat        TelegramChat?

  @@unique([source, externalChatId])
  @@index([contactId])
  @@index([source])
  @@index([lastMessageAt(sort: Desc)])
  @@index([needsReply])
  @@index([priorityScore])
  @@index([hasQuestion])
  @@index([syncStatus])
  @@index([isSyncDisabled])
  @@index([unreadCount])
}

model Message {
  id                String                   @id @default(cuid())
  conversationId    String
  contactId         String?
  source            String
  externalMessageId String
  direction         String
  contentType       String
  subject           String?
  body              String?
  status            String?
  sentAt            DateTime
  deliveredAt       DateTime?
  readAt            DateTime?
  containsQuestion  Boolean                  @default(false)
  sentiment         String?
  keywords          String[]
  hasAttachments    Boolean                  @default(false)
  attachments       Json?
  metadata          Json?
  createdAt         DateTime                 @default(now())
  search_vector     Unsupported("tsvector")?
  campaignMessage   CampaignMessage?
  contact           Contact?                 @relation(fields: [contactId], references: [id])
  conversation      Conversation             @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([source, conversationId, externalMessageId])
  @@index([conversationId])
  @@index([contactId])
  @@index([sentAt(sort: Desc)])
  @@index([source])
  @@index([containsQuestion])
  @@index([direction])
  @@index([search_vector], map: "msg_search_vector_idx", type: Gin)
}

model GroupMember {
  id             String       @id @default(cuid())
  conversationId String
  externalUserId String
  username       String?
  firstName      String?
  lastName       String?
  role           String?
  joinedAt       DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([conversationId, externalUserId])
  @@index([conversationId])
  @@index([externalUserId])
}

model FollowUp {
  id             String        @id @default(cuid())
  conversationId String?
  contactId      String?
  title          String
  notes          String?
  priority       String        @default("medium")
  status         String        @default("pending")
  dueDate        DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  contact        Contact?      @relation(fields: [contactId], references: [id])
  conversation   Conversation? @relation(fields: [conversationId], references: [id])

  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([contactId])
}

model Campaign {
  id               String            @id @default(cuid())
  name             String
  description      String?
  targetingType    String
  targetingRules   Json?
  channels         String[]
  messageTemplates Json
  scheduleType     String
  scheduledFor     DateTime?
  timezone         String?
  status           String            @default("draft")
  recipientCount   Int               @default(0)
  sentCount        Int               @default(0)
  deliveredCount   Int               @default(0)
  readCount        Int               @default(0)
  repliedCount     Int               @default(0)
  failedCount      Int               @default(0)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  messages         CampaignMessage[]

  @@index([status])
  @@index([scheduledFor])
}

model CampaignMessage {
  id            String    @id @default(cuid())
  campaignId    String
  contactId     String
  messageId     String?   @unique
  channel       String
  status        String    @default("pending")
  sentAt        DateTime?
  deliveredAt   DateTime?
  readAt        DateTime?
  repliedAt     DateTime?
  failureReason String?
  retryCount    Int       @default(0)
  createdAt     DateTime  @default(now())
  campaign      Campaign  @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  contact       Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  message       Message?  @relation(fields: [messageId], references: [id])

  @@index([campaignId])
  @@index([contactId])
  @@index([status])
  @@index([channel])
}

model Workflow {
  id           String        @id @default(cuid())
  name         String
  description  String?
  triggerType  String
  triggerRules Json
  actions      Json
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  runs         WorkflowRun[]

  @@index([isActive])
  @@index([triggerType])
}

model WorkflowRun {
  id           String    @id @default(cuid())
  workflowId   String
  contactId    String?
  status       String
  triggeredBy  String?
  startedAt    DateTime?
  completedAt  DateTime?
  executionLog Json?
  createdAt    DateTime  @default(now())
  workflow     Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([workflowId])
  @@index([status])
  @@index([createdAt])
}

model Broadcast {
  id             String    @id @default(cuid())
  title          String
  message        String
  tagIds         Json
  status         String    @default("draft")
  scheduledFor   DateTime?
  sentAt         DateTime?
  recipientCount Int?
  sentCount      Int?
  failedCount    Int?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([scheduledFor])
}

model SyncJob {
  id             String    @id @default(cuid())
  jobType        String
  source         String
  status         String    @default("pending")
  conversationId String?
  cursor         String?
  startedAt      DateTime?
  completedAt    DateTime?
  itemsProcessed Int       @default(0)
  itemsFailed    Int       @default(0)
  errors         Json?
  retryCount     Int       @default(0)
  nextRetryAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([status])
  @@index([source])
  @@index([jobType])
  @@index([conversationId])
  @@index([createdAt])
}

model SyncHealth {
  id                  String   @id @default(cuid())
  syncType            String
  source              String
  status              String
  totalItems          Int      @default(0)
  successCount        Int      @default(0)
  failureCount        Int      @default(0)
  duration            Int?
  circuitBreakerState String?
  errors              Json?
  createdAt           DateTime @default(now())

  @@index([syncType, source])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

model TelegramChat {
  id             String       @id @default(cuid())
  conversationId String       @unique
  telegramChatId String       @unique
  type           String
  title          String?
  username       String?
  memberCount    Int?
  isActive       Boolean      @default(true)
  metadata       Json?
  lastSyncedAt   DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([telegramChatId])
  @@index([type])
}

model TelegramSession {
  id            String   @id @default(cuid())
  sessionType   String   @unique
  sessionString String
  phoneNumber   String
  isActive      Boolean  @default(true)
  lastUsedAt    DateTime @updatedAt
  createdAt     DateTime @default(now())
  session_name  String   @unique(map: "unique_session_name") @default("default") @db.VarChar(255)

  @@index([isActive])
  @@index([phoneNumber])
}

model SyncLock {
  id          String   @id @default(cuid())
  lockType    String
  lockKey     String
  processId   String
  hostname    String?
  acquiredAt  DateTime @default(now())
  expiresAt   DateTime
  heartbeatAt DateTime @default(now())
  metadata    Json?

  @@unique([lockType, lockKey])
  @@index([expiresAt])
  @@index([processId])
}

model ListenerState {
  id               String    @id @default("singleton")
  status           String
  lastHeartbeat    DateTime  @default(now())
  lastMessageAt    DateTime?
  processId        String?
  hostname         String?
  startedAt        DateTime?
  messagesReceived Int       @default(0)
  connectionInfo   Json?
  errors           Json?
  updatedAt        DateTime  @updatedAt
}

model TelegramWorkerSession {
  id           Int       @id @default(autoincrement())
  session_name String    @unique @default("default") @db.VarChar(255)
  session_data Bytes
  created_at   DateTime? @default(now()) @db.Timestamptz(6)
  updated_at   DateTime? @default(now()) @db.Timestamptz(6)
}

// LINEAR-STYLE OUTBOX: Reliable message sending queue
// Messages are stored here first, then processed by the Telegram worker
// This ensures 100% delivery even if the worker crashes
model OutgoingMessage {
  id                String    @id @default(cuid())
  conversationId    String

  // Message content
  text              String?                   // Text body (optional if sending media only)
  replyToMessageId  String?                   // External message ID to reply to

  // Attachments (Telegram-style: photo, document, video, audio, voice)
  attachmentType    String?                   // 'photo' | 'document' | 'video' | 'audio' | 'voice' | null
  attachmentUrl     String?                   // URL or file path to the attachment
  attachmentName    String?                   // Original filename for documents
  attachmentMimeType String?                  // MIME type for proper handling
  attachmentCaption String?                   // Caption for media (Telegram supports this)

  // Delivery status (Linear-style state machine)
  status            String    @default("pending")  // 'pending' | 'sending' | 'sent' | 'failed'
  sentMessageId     String?                        // Telegram message ID after sending
  errorMessage      String?                        // Error details if failed
  retryCount        Int       @default(0)          // Number of retry attempts
  maxRetries        Int       @default(3)          // Maximum retries before permanent failure

  // Processing metadata
  lockedBy          String?                   // Worker process ID that claimed this message
  lockedAt          DateTime?                 // When the lock was acquired
  scheduledFor      DateTime?                 // For scheduled messages (future feature)

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  sentAt            DateTime?                 // When actually sent to Telegram

  // Relations
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([conversationId])
  @@index([createdAt])
  @@index([scheduledFor])
  @@index([lockedBy, lockedAt])
}

// File uploads storage for attachments
model FileUpload {
  id            String    @id @default(cuid())
  filename      String                    // Original filename
  mimeType      String                    // MIME type
  size          Int                       // File size in bytes
  storageKey    String    @unique         // Key in storage (local path or cloud URL)
  storageType   String    @default("local") // 'local' | 's3' | 'cloudflare'
  uploadedBy    String?                   // User/session identifier
  expiresAt     DateTime?                 // For temporary files
  metadata      Json?                     // Additional file metadata
  createdAt     DateTime  @default(now())

  @@index([storageKey])
  @@index([createdAt])
  @@index([expiresAt])
}
